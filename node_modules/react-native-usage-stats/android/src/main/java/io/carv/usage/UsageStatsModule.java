package io.carv.usage;

import static android.Manifest.permission.PACKAGE_USAGE_STATS;
import static android.app.AppOpsManager.OPSTR_GET_USAGE_STATS;

import android.annotation.TargetApi;
import android.app.AppOpsManager;
import android.app.usage.UsageStats;
import android.app.usage.UsageStatsManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Build;
import android.os.Process;
import android.provider.Settings;

import androidx.annotation.NonNull;

import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableMap;

import java.util.List;
import java.util.Map;

public class UsageStatsModule extends ReactContextBaseJavaModule {
    private static ReactApplicationContext reactContext;

    public UsageStatsModule(ReactApplicationContext context) {
        super(context);
        reactContext = context;
    }

    @NonNull
    @Override
    public String getName() {
        return "UsageStats";
    }

    @ReactMethod
    @TargetApi(Build.VERSION_CODES.N)
    public void checkPermission(Promise promise) {
        boolean granted;
        AppOpsManager appOpsManager = (AppOpsManager) reactContext.getSystemService(Context.APP_OPS_SERVICE);
        int mode = appOpsManager.checkOpNoThrow(OPSTR_GET_USAGE_STATS, Process.myUid(), reactContext.getPackageName());

        if (mode == AppOpsManager.MODE_DEFAULT) {
            granted = (reactContext.checkCallingOrSelfPermission(PACKAGE_USAGE_STATS) == PackageManager.PERMISSION_GRANTED);
        } else {
            granted = (mode == AppOpsManager.MODE_ALLOWED);
        }
        promise.resolve(granted);
    }

    @ReactMethod
    public void openUsageAccessSettings(String packageName, Promise promise) {
        try {
            Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);
            intent.setData((Uri.fromParts("package", packageName, null)));
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            getCurrentActivity().startActivity(intent);
        } catch (Exception error) {
            promise.reject("error", error.getMessage());
        }
    }

    @ReactMethod
    public void getAppUsageStats(String packageName, double beginTime, double endTime, Promise promise) {
        UsageStatsManager usageStatsManager = (UsageStatsManager) getReactApplicationContext().getSystemService(Context.USAGE_STATS_SERVICE);
        if (usageStatsManager == null) {
            promise.reject("ERROR", "UsageStatsManager not found");
            return;
        }
        Map<String, UsageStats> usageStatsMap = usageStatsManager.queryAndAggregateUsageStats((long) beginTime, (long) endTime);
        if (usageStatsMap == null || usageStatsMap.isEmpty()) {
            promise.reject("ERROR", "UsageStatsList is empty");
            return;
        }
        UsageStats usageStats = usageStatsMap.get(packageName);
        if (usageStats == null) {
            // no app data
            promise.resolve(null);
            return;
        }
        WritableMap map = Arguments.createMap();
//        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
//            map.putDouble("lastTimeForegroundServiceUsed", usageStats.getLastTimeForegroundServiceUsed());
//            map.putDouble("lastTimeVisible", usageStats.getLastTimeVisible());
//            map.putDouble("totalTimeForegroundServiceUsed()", usageStats.getTotalTimeForegroundServiceUsed());
//            map.putDouble("totalTimeVisible()", usageStats.getTotalTimeVisible());
//        }
        map.putDouble("firstTimeStamp", usageStats.getFirstTimeStamp());
        map.putDouble("lastTimeStamp", usageStats.getLastTimeStamp());
        map.putDouble("lastTimeUsed", usageStats.getLastTimeUsed());
        map.putString("packageName", usageStats.getPackageName());
        map.putDouble("usageTime", usageStats.getTotalTimeInForeground());
        promise.resolve(map);
    }

    @ReactMethod
    public void getAppListUsageStats(ReadableArray packageNames, double beginTime, double endTime, Promise promise) {
        UsageStatsManager usageStatsManager = (UsageStatsManager) getReactApplicationContext().getSystemService(Context.USAGE_STATS_SERVICE);
        if (usageStatsManager == null) {
            promise.reject("ERROR", "UsageStatsManager not found");
            return;
        }
        Map<String, UsageStats> usageStatsMap = usageStatsManager.queryAndAggregateUsageStats((long) beginTime, (long) endTime);
        if (usageStatsMap == null || usageStatsMap.isEmpty()) {
            promise.reject("ERROR", "UsageStatsList is empty");
            return;
        }

        WritableArray usageList = Arguments.createArray();
        for (int i = 0; i < packageNames.size(); i++) {
            String packageName = packageNames.getString(i);
            UsageStats usageStats = usageStatsMap.get(packageName);
            if (usageStats != null) {
                WritableMap usageMap = Arguments.createMap();
                usageMap.putDouble("firstTimeStamp", usageStats.getFirstTimeStamp());
                usageMap.putDouble("lastTimeStamp", usageStats.getLastTimeStamp());
                usageMap.putDouble("lastTimeUsed", usageStats.getLastTimeUsed());
                usageMap.putString("packageName", usageStats.getPackageName());
                usageMap.putDouble("usageTime", usageStats.getTotalTimeInForeground());
                usageList.pushMap(usageMap);
            }
        }
        promise.resolve(usageList);

    }

    @ReactMethod
    public void getAppUsageInfo(Promise promise) {
        UsageStatsManager usageStatsManager = (UsageStatsManager) getReactApplicationContext().getSystemService(Context.USAGE_STATS_SERVICE);
        if (usageStatsManager == null) {
            promise.reject("ERROR", "UsageStatsManager not found");
            return;
        }

        List<UsageStats> usageStatsList = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_BEST, 0, System.currentTimeMillis());
        if (usageStatsList == null || usageStatsList.isEmpty()) {
            promise.reject("ERROR", "UsageStatsList is empty");
            return;
        }

        WritableArray appUsageInfo = Arguments.createArray();
        for (UsageStats usageStats : usageStatsList) {
            if (usageStats.getTotalTimeInForeground() > 1000) {
//                    ApplicationInfo applicationInfo = getReactApplicationContext().getPackageManager().getApplicationInfo(usageStats.getPackageName(), 0);
//                    String appName = (String) getReactApplicationContext().getPackageManager().getApplicationLabel(applicationInfo);
                WritableMap appInfo = Arguments.createMap();
                appInfo.putString("packageName", usageStats.getPackageName());
//                    appInfo.putString("appName", appName);
                appInfo.putDouble("firstTimeStamp", usageStats.getFirstTimeStamp());
                appInfo.putDouble("lastTimeStamp", usageStats.getLastTimeStamp());
                appInfo.putDouble("lastTimeUsed", usageStats.getLastTimeUsed());
                appInfo.putString("packageName", usageStats.getPackageName());
                appInfo.putDouble("usageTime", usageStats.getTotalTimeInForeground());
                appUsageInfo.pushMap(appInfo);
            }
        }

        promise.resolve(appUsageInfo);
    }

    @ReactMethod
    // Open the first available package in the list
    public void openAppList(ReadableArray packageNames, Promise promise) {
        PackageManager packageManager = reactContext.getPackageManager();
        for (int i = 0; i < packageNames.size(); i++) {
            String packageName = packageNames.getString(i);
            Intent intent = packageManager.getLaunchIntentForPackage(packageName);
            if (intent != null) {
                reactContext.startActivity(intent);
                return;
            }
        }
        String firstPackageName = packageNames.getString(0);
        try {
            Uri appUri = Uri.parse("market://details?id=" + firstPackageName);
            Intent marketIntent = new Intent(Intent.ACTION_VIEW, appUri);
            marketIntent.setPackage("com.android.vending");
            marketIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            reactContext.startActivity(marketIntent);
        } catch (Exception e) {
            String url = "https://play.google.com/store/apps/details?id=" + firstPackageName;
            try {
                Intent urlIntent = new Intent(Intent.ACTION_VIEW);
                urlIntent.setData(Uri.parse(url));
                urlIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                reactContext.startActivity(urlIntent);
            } catch (Exception exception) {
                promise.reject("OpenError", e.getMessage());
            }
        }
    }

    @ReactMethod
    public void openApp(String packageName, Promise promise) {
        PackageManager packageManager = reactContext.getPackageManager();
        Intent intent = packageManager.getLaunchIntentForPackage(packageName);
        if (intent != null) {
            reactContext.startActivity(intent);
        } else {
            try {
                Uri appUri = Uri.parse("market://details?id=" + packageName);
                Intent marketIntent = new Intent(Intent.ACTION_VIEW, appUri);
                marketIntent.setPackage("com.android.vending");
                marketIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                reactContext.startActivity(marketIntent);
            } catch (Exception e) {
                String url = "https://play.google.com/store/apps/details?id=" + packageName;
                try {
                    Intent urlIntent = new Intent(Intent.ACTION_VIEW);
                    urlIntent.setData(Uri.parse(url));
                    urlIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    reactContext.startActivity(urlIntent);
                } catch (Exception exception) {
                    promise.reject("OpenError", e.getMessage());
                }
            }
        }
    }

    @ReactMethod
    public void openNotificationSettings() {
        Intent intent = new Intent();
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            intent.setAction(Settings.ACTION_APP_NOTIFICATION_SETTINGS);
            intent.putExtra(Settings.EXTRA_APP_PACKAGE, reactContext.getPackageName());
        } else if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
            intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS");
            intent.putExtra("app_package", reactContext.getPackageName());
            intent.putExtra("app_uid", reactContext.getApplicationInfo().uid);
        } else {
            intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
            intent.addCategory(Intent.CATEGORY_DEFAULT);
            intent.setData(Uri.parse("package:" + reactContext.getPackageName()));
        }
        getCurrentActivity().startActivity(intent);
    }

    @ReactMethod
    public void queryUsageStats(double beginTime, double endTime, Promise promise) {
        UsageStatsManager usageStatsManager = (UsageStatsManager) getReactApplicationContext().getSystemService(Context.USAGE_STATS_SERVICE);
        if (usageStatsManager == null) {
            promise.reject("ERROR", "UsageStatsManager not found");
            return;
        }

        List<UsageStats> usageStatsList = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_BEST, (long) beginTime, (long) endTime);
        if (usageStatsList == null || usageStatsList.isEmpty()) {
            promise.reject("ERROR", "UsageStatsList is empty");
            return;
        }

        WritableArray appUsageInfo = Arguments.createArray();
        for (UsageStats usageStats : usageStatsList) {
//            if (usageStats.getTotalTimeInForeground() > 0) {
            WritableMap appInfo = Arguments.createMap();
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                appInfo.putDouble("lastTimeForegroundServiceUsed", usageStats.getLastTimeForegroundServiceUsed());
                appInfo.putDouble("lastTimeVisible", usageStats.getLastTimeVisible());
                appInfo.putDouble("totalTimeForegroundServiceUsed", usageStats.getTotalTimeForegroundServiceUsed());
                appInfo.putDouble("totalTimeVisible", usageStats.getTotalTimeVisible());
            }
            appInfo.putString("packageName", usageStats.getPackageName());
            appInfo.putDouble("firstTimeStamp", usageStats.getFirstTimeStamp());
            appInfo.putDouble("lastTimeStamp", usageStats.getLastTimeStamp());
            appInfo.putDouble("lastTimeUsed", usageStats.getLastTimeUsed());
            appInfo.putDouble("totalTimeInForeground", usageStats.getTotalTimeInForeground());
            appUsageInfo.pushMap(appInfo);
//            }
        }
        promise.resolve(appUsageInfo);
    }


    @ReactMethod
    public void queryAndAggregateUsageStats(double beginTime, double endTime, Promise promise) {
        UsageStatsManager usageStatsManager = (UsageStatsManager) getReactApplicationContext().getSystemService(Context.USAGE_STATS_SERVICE);
        if (usageStatsManager == null) {
            promise.reject("ERROR", "UsageStatsManager not found");
            return;
        }

        Map<String, UsageStats> usageStatsMap = usageStatsManager.queryAndAggregateUsageStats((long) beginTime, (long) endTime);
        if (usageStatsMap == null || usageStatsMap.isEmpty()) {
            promise.reject("ERROR", "UsageStatsList is empty");
            return;
        }

        WritableMap appUsageInfo = Arguments.createMap();
        for (UsageStats usageStats : usageStatsMap.values()) {
//            if (usageStats.getTotalTimeInForeground() > 0) {
            WritableMap appInfo = Arguments.createMap();
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                appInfo.putDouble("lastTimeForegroundServiceUsed", usageStats.getLastTimeForegroundServiceUsed());
                appInfo.putDouble("lastTimeVisible", usageStats.getLastTimeVisible());
                appInfo.putDouble("totalTimeForegroundServiceUsed", usageStats.getTotalTimeForegroundServiceUsed());
                appInfo.putDouble("totalTimeVisible", usageStats.getTotalTimeVisible());
            }
            appInfo.putString("packageName", usageStats.getPackageName());
            appInfo.putDouble("firstTimeStamp", usageStats.getFirstTimeStamp());
            appInfo.putDouble("lastTimeStamp", usageStats.getLastTimeStamp());
            appInfo.putDouble("lastTimeUsed", usageStats.getLastTimeUsed());
            appInfo.putDouble("totalTimeInForeground", usageStats.getTotalTimeInForeground());
            appUsageInfo.putMap(usageStats.getPackageName(), appInfo);
//            }
        }
        promise.resolve(appUsageInfo);
    }

}